package org.archive.modules.extractor.jsexecutor;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.logging.Logger;


import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathFactory;

import org.apache.commons.httpclient.URIException;
import org.archive.io.ReplayInputStream;
import org.archive.modules.Processor;
import org.archive.modules.ProcessorURI;
import org.archive.modules.extractor.ExtractorHTML;
import org.archive.modules.extractor.HTMLLinkContext;
import org.archive.modules.extractor.Hop;
import org.archive.modules.extractor.Link;
import org.archive.modules.extractor.UriErrorLoggerModule;
import org.archive.net.UURIFactory;
import org.archive.settings.Finishable;
import org.archive.state.Initializable;
import org.archive.state.Key;
import org.archive.state.KeyManager;
import org.archive.state.StateProvider;
import org.archive.util.Recorder;
import org.lobobrowser.html.UserAgentContext;
import org.lobobrowser.html.domimpl.HTMLDocumentImpl;
import org.lobobrowser.html.js.Window;
import org.lobobrowser.html.parser.DocumentBuilderImpl;
import org.lobobrowser.html.parser.InputSourceImpl;
import org.lobobrowser.html.test.SimpleUserAgentContext;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

/**
 * An advanced link extractor
 * 
 * <p>Parse HTML document and evaluate JavaScript code within it
 * using cobra parser with embedded Rhino JS engine.
 * <p>Be able to extract links generated by JS code using XPath from HTML DOM.
 * Be able to simulate HTML events to find new links.
 *
 * @author Ping
 *
 */

public class ExecuteJS extends Processor implements Initializable, Finishable {
    private static final long serialVersionUID = 1L;
    
    private static Logger logger =
        Logger.getLogger(ExecuteJS.class.getName());
    
    private HashSet<String> handledUris;

    final public static Key<UriErrorLoggerModule> URI_ERROR_LOGGER_MODULE = 
        Key.makeAuto(UriErrorLoggerModule.class);
    
    static {
        KeyManager.addKeys(ExecuteJS.class);
    }
    
    protected UriErrorLoggerModule uriErrors;
    
    public void initialTasks(StateProvider global) {
        this.uriErrors = global.get(this, URI_ERROR_LOGGER_MODULE);        
    }
    
    public void finalTasks(StateProvider global) {
        
    }

    final protected boolean shouldProcess(ProcessorURI uri) {
        //Check if uri is an HTML document
        String uristr = uri.getUURI().toString().toLowerCase();
        if (! uristr.endsWith(".html") && ! uristr.endsWith(".htm")) {
            return false;
        }
        
        if (uri.getContentLength() <= 0) {
            return false;
        }
        
        if (!shouldExecuteJS(uri)) {
            return false;
        }
        return true;
    }
    
    protected void innerProcess(ProcessorURI uri)
    throws InterruptedException {
        Document document;
        if ((document = parse(uri)) != null) {
            discoverNewLinks(uri, document);
            
            if (shouldSimHTMLEvents()) {
                handleHTMLEvents(uri, document);
            }
            
            /*for (Link wref: uri.getOutLinks()) {
                System.out.println(wref.getDestination());
            }*/
            
            getHandledLinks().clear();
        }
    }

    // TODO: based on user's configurateion to decide
    protected boolean shouldSimHTMLEvents() {
        return true;
    }

    // TODO: based on user's configurateion to decide
    protected boolean shouldExecuteJS(ProcessorURI uri) {
        return true;
    }

    /**
     * Parse HTML document, and generate DOM tree, 
     * inlined JavaScript code is executed. 
     * @param uri
     * @return
     */
    protected Document parse(ProcessorURI uri) {
        //System.out.println("Parse link: " + uri.getUURI().toString());
        try {
            //Get memebers associated with current crawlUri            
            String uriStr = uri.getUURI().toCustomString();
            Recorder recorder = uri.getRecorder();
            ReplayInputStream replayIn = recorder.getReplayInputStream();
            replayIn.skip(replayIn.getHeaderSize());
            
            //Set up document builder
            UserAgentContext ucontext = new SimpleUserAgentContext();
            InputSourceImpl inputSource = new InputSourceImpl(replayIn, 
                    uriStr, recorder.getCharacterEncoding());
            DocumentBuilderImpl builder = new DocumentBuilderImpl(ucontext);            
            
            //Create a DOM
            HTMLDocumentImpl document = 
                (HTMLDocumentImpl) builder.createDocument(inputSource);
            
            //Parse the document
            document.load();
            return document;
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        return null;
    }
    
    /**
     * Discover new links, including anchor and img tags.
     * @param uri current uri
     * @param document DOM generated
     */
    protected void discoverNewLinks(ProcessorURI uri, Document document) {
        
        handleRedirection(uri, document);
        extractLinksFromDOM(uri, document);
    }
    
    /**
     * Simulate HTML events, and discover new link after simulation
     * @param uri
     * @param document
     */
    protected void handleHTMLEvents(ProcessorURI uri, Document document) {
        ArrayList<String> eventsToSim = null;
        if ((eventsToSim = getEventsToSim()) == null)
            return;
        
        int numOfEventsToSim = eventsToSim.size();
        HTMLEventHandler eventHandler = new HTMLEventHandler(document);
        for (int i = 0; i < numOfEventsToSim; ++ i) {
            simHTMLEvent(eventsToSim.get(i), eventHandler);
            discoverNewLinks(uri, document);
        }
    }
    
    /**
     * Simulate each type of HTML event
     * @param event type of HTML event
     * @param eventHandler
     */
    protected void simHTMLEvent(String event, HTMLEventHandler eventHandler) {
        if (event.equalsIgnoreCase("onclick")) {
            eventHandler.simMouseClick();
        } else if (event.equalsIgnoreCase("onmouseover")) {
            eventHandler.simMouseOver();
        } else if (event.equalsIgnoreCase("onmouseout")) {
            eventHandler.simMouseOut();
        }
    }
    
    /**
     * Check if JS redirection happened, if so, add a new link and mark it as
     * navigation link not a referrer link
     * @param curi
     * @param document
     */
    protected void handleRedirection(ProcessorURI curi, Document document) {
        String newUri = null;
        if ((newUri = getJSRedirection((HTMLDocumentImpl)document)) != null) {
            if (getHandledLinks().add(newUri)) {
                addLinkFromString(curi, newUri, "JSRedirection", Hop.NAVLINK);
            }
        }
    }
    
    /**
     * Find links from a DOM
     * @param uri
     * @param document
     */
    protected void extractLinksFromDOM(ProcessorURI uri, Document document) {
        extractImgUris(uri, document);
        extractAnchorUris(uri, document);
    }
    
    /**
     * Find image source links
     * @param uri
     * @param document
     */
    private void extractImgUris(ProcessorURI uri, Document document) {
        NodeList nodeList = extractUrisFromDOM(document, "html//img");
        
        if (nodeList != null) {
            int size = nodeList.getLength();
            for (int i = 0; i < size; ++ i) {
                Element element = (Element) nodeList.item(i);
                String value = element.getAttribute("src");
                if (value != null && getHandledLinks().add(value)) {
                    CharSequence context = 
                        ExtractorHTML.elementContext("img", "src");
                    addLinkFromString(uri, value, context, Hop.EMBED);
                }
            }
        }
    }
    
    /**
     * Find anchor href links
     * @param uri
     * @param document
     */
    private void extractAnchorUris(ProcessorURI uri, Document document) {
        NodeList nodeList = extractUrisFromDOM(document, "html//a");
        
        if (nodeList != null) {
            int size = nodeList.getLength();
            for (int i = 0; i < size; ++ i) {
                Element element = (Element) nodeList.item(i);
                String value = element.getAttribute("href");
                if (value != null && getHandledLinks().add(value)) {
                    CharSequence context = 
                        ExtractorHTML.elementContext("a", "href");
                    addLinkFromString(uri, value, context, Hop.NAVLINK);
                }
            }
        }
    }
    
    /**
     * Given a XPath expression, find a list of nodes
     * @param document
     * @param evalStr XPath expression
     * @return
     */
    protected NodeList extractUrisFromDOM(Document document, String evalStr) {
        NodeList nodeList = null;
        XPath xpath = XPathFactory.newInstance().newXPath();
        try {
            nodeList = (NodeList) xpath.evaluate(evalStr, 
                    document, XPathConstants.NODESET);
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        return nodeList;
    }
    
    /**
     * Copied from class ExtractorHTML
     * @param uri
     * @param value
     * @param context
     * @param hop
     */
    private void addLinkFromString(ProcessorURI uri, String value,
            CharSequence context, Hop hop) {
        try {
            // We do a 'toString' on context because its a sequence from
            // the underlying ReplayCharSequence and the link its about
            // to become a part of is expected to outlive the current
            // ReplayCharSequence.
            HTMLLinkContext hc = new HTMLLinkContext(context.toString());
            int max = uriErrors.getMaxOutlinks(uri);
            Link.addRelativeToBase(uri, max, value, hc, hop);
        } catch (URIException e) {
            logUriError(e, uri, value);
        }
    }
    
    // TODO: Get user's configuration
    private ArrayList<String> getEventsToSim() {
        ArrayList<String> eventsToSim = new ArrayList<String>();
        eventsToSim.add("onmouseover");
        eventsToSim.add("onmouseout");
        eventsToSim.add("onclick");
        return eventsToSim;
    }
    
    /**
     * Get JavaScript redirection
     * @param document
     * @return uri of JS redirection, return null if no redirection
     */
    protected String getJSRedirection(HTMLDocumentImpl document) {
        
        Window window = (Window) document.getDefaultView();
        String locationHref = window.getLocation().getLocationHref();
        if (locationHref != null && !locationHref.equals(document.getURL())) {
            //System.out.println("JS redirection happened");
            return locationHref;
        }
        
        return null;
    }

    /**
     * Copied from class ExtractorHTML
     * @param e
     * @param uri
     * @param l
     */
    protected void logUriError(URIException e, ProcessorURI uri, 
            CharSequence l) {
        if (e.getReasonCode() == UURIFactory.IGNORED_SCHEME) {
            // don't log those that are intentionally ignored
            return; 
        }
        uriErrors.logUriError(e, uri.getUURI(), l);
    }
    
    /**
     * Get a collection of extracted links which have been handled
     * @return
     */
    private HashSet<String> getHandledLinks() {
        if (handledUris == null) {
            handledUris = new HashSet<String>();
        }
        return handledUris;
    }
}