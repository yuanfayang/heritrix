<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
</head>
<body bgcolor="white">

Provides application configuration.


<h2>Package Specification</h2>

<h3>Axioms and Assumptions</h3>
<ul>
<li>Configurable objects will depend on <code>org.archive.configuration</code>.
It will have at least the base Configurable and Registry interfaces.</li>
</li>
<li>Every setting/configuration is a <a 
href="http://java.sun.com/j2se/1.5.0/docs/api/javax/management/openmbean/package-summary.html">javax.management.openmbean</a> JMX Attribute.  OpenMBeans are the basis of the *new* Settings system
(This package replaces the *old* <code>org.archive.crawler.settings</code>
package).  OpenMBean JMX Attributes have name, value, description, default, and
constraints.</li>
    <li>Classes that are <i>configurable</i> implement
    <i>Configurable</i> and have a
    <i>Configuration</i>.  A Configuration describes whats configurable,
    defaults and constraints using an MBean composition,
	<a href="http://java.sun.com/j2se/1.5.0/docs/api/javax/management/MBeanInfo.html">MBeanInfo</a>: Has means of interrogating list of 
	OpenMBean JMX Attributes, etc.
    </li>
    <li>Configurable Classes look up Configuration in the <i>Registry</i>.
    Configuration gotten any other way is *dead* as oppposed to *live*
    Configuration.  Only Registry has true state of Configuration.
    Registry is passed on initialization.  Configurable Classes can keep
    reference to Registry for future use or configure all on initialization
    and then let the Registry go.</li>
    <li><i>Registry</i> implementation can be swapped out and an alternate used
	just by changing system property.  Same for Configuration <i>Store</i>.
	</li>
    <li>For naming in the Registry, we use another MBean feature, 
	<code>java.management.ObjectName</code>.
	ObjectNames look like:
	<code>domain:key1=value1,key2=value2,etc.</code>. Here is an
	example: <code>org.archive.crawler:name=Heritrix,type=Crawler</code>.
	ObjectName has convenience methods for parsing ObjectName strings into
	domain and key/value parts.
	We'll use ObjectNames for Configuration instances in Registry.
	Configuration must have a name and type (and domain).
	For now, type is class name of Configurations' Configurable.	
	Overrides will be done with the domain part of ObjectName.
    </li>
</ul>

<h3>Example Configurable Class Implementation</h3>
<pre>
TODO Static inner class.
TODO Static dynamic class.
</pre>

<h3>Model</h3>
<img alt="Configuration model" src="configuration.gif" />

<h3>TODOs</h3>
<ul>
    <li>Notifications: Missing from the Model below are setters.
    If we add setters, then Notifications are done by the Registry
    implementation (E.g. JMX or JNDI Notification implementations).
    </li>
    <li>Invocations: JMX advertises operations. JNDI has similar.
    Implication is that Configuration has reference to Configurable Class.
    </li>
    <li>Configuration Design: How does it know list of implementations. Once
    it has a Configurable Class, it can query for allowed values but bootstrapping    and then adding in new implementations and having them noticed?
    Can't this just be a list in Configuration?  And then add to the list via
    the UI?  Add new implementations?
    </li>
    <li>Serializing: Write out all values or just whats other than default?
    Option?</li>
    <li>Checkpointing: Do I just have to write out Configurations?
	If the Configuration carries current state of an object?  If
	the Configuration is updated with the state of all counters,
	should be sufficent?  Test.
	</li>
	<li>Pointers to Pointers of configuration so can have one instance
	of a configuration used by many?
	</li>
	<li>Groups of Configurables?</li>
	<li>Not reproducing complete Configurable in override, just
	the values that are overrideable and the differences?</li>
	<li>Set the not-writeable in Overriddes if Attribute is not
	overrideable?  How?</li>
    <li>Paul Jack suggests using annotations to mark Configurable classes
    and for marking whats configurable rather than an Interface and
    leveraging OpenMBean self-description with description, defaults and
    ranges. Investigate.
    </li>
</ul>

<h3>Comparison to old Settings system</h3>
<ul>
	<li>No boostrapping of core components is done by this system.
	Should make it so don't have to instantiate all that comes
	before in the configuration hierarchy -- e.g. A SettingsHandler and then
    a CrawlOrder and then a FetchHTTP -- testing or reusing in another context.
	</li>
    <li>Because we are implementing interfaces only to make a Configurable
    object, the core implementation can be done off in a base POJO and
    Configuration added later in a subclass.  This base POJO could then be used
    freely in other contexts without dependencies on Configurable (Settings).
    We couldn't do this with old setting system.  In the old system you couldn't
    use FetchHTTP without bringing over the settings system super
    classes (Brad suggests we take on the practise when refactoring of
    implementing base class first then subclassing to implement Configurable.
    He wants FetchHTTP and ARCWriter, etc).
    </li>
</ul>


<h2>Risks</h2>
<ul>
<li>Lookup into JMXRegistry will be too slow (Worst-case would be
Registry is a Singleton that all threads go via).  Should this be the case,
if caching is insufficent, things to try:
    <ul><li>Alternate JMX implementation.  In the past, the JVM Reference
    Implementation has been slammed as being dog slow. Other JMX
    implementations to try include MX4J (tomcat, geronimo, etc.) or
    JBOSS or our own JBOSS-like Map based version that shortcircuits
    JMX Agent if all in same JVM.
    </li>
    <li>Do Configuration once at head of processing chain.</li>
    </ul>
</li>
</ul>
</p>

<h2>Context</h2>
<p>This package is a refactoring of the org.archive.crawler.settings
package.  See <a href="">Settings Framework Refactoring</a> document
for a lead in on how this package came about.</p>

</body>
</html>
