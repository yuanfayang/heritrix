<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
</head>
<body bgcolor="white">

Provides application configuration.


<h2>Package Specification</h2>

<h3>Axioms and Assumptions</h3>
<ul>
<li>Configurable objects will depend on <code>org.archive.configuration</code>.
It will have at least the base Configurable and Registry interfaces.</li>
</li>
<li>Every setting/configuration is a <a 
href="http://java.sun.com/j2se/1.5.0/docs/api/javax/management/openmbean/package-summary.html">javax.management.openmbean</a> JMX Attribute.  OpenMBeans are the basis of the *new* Settings system
(This package replaces the *old* <code>org.archive.crawler.settings</code>
package).  OpenMBean JMX Attributes have name, value, description, default, and
constraints.</li>
    <li>Classes that are <i>configurable</i> implement
    <i>Configurable</i> and have a
    <i>Configuration</i>.  A Configuration describes whats configurable,
    defaults and constraints using an MBean composition,
	<a href="http://java.sun.com/j2se/1.5.0/docs/api/javax/management/MBeanInfo.html">MBeanInfo</a>: Has means of interrogating list of 
	OpenMBean JMX Attributes, etc.
    </li>
    <li>Configurable Classes look up Configuration in the <i>Registry</i>.
    Configuration gotten any other way is *dead* as oppposed to *live*
    Configuration.  Only Registry has true state of Configuration.
    Registry is passed on initialization.  Configurable Classes can keep
    reference to Registry for future use or configure all on initialization
    and then let the Registry go.</li>
    <li><i>Registry</i> implementation can be swapped out and an alternate used
	just by changing system property.  Same for Configuration <i>Store</i>.
	</li>
    <li>For naming in the Registry, we use another MBean feature, 
	<code>java.management.ObjectName</code>.
	ObjectNames look like:
	<code>domain:key1=value1,key2=value2,etc.</code>. Here is an
	example: <code>org.archive.crawler:name=Heritrix,type=Crawler</code>.
	ObjectName has convenience methods for parsing ObjectName strings into
	domain and key/value parts.
	We'll use ObjectNames for Configuration instances in Registry.
	Configuration must have a name and type (and domain).
	For now, type is class name of Configurations' Configurable.	
	Overrides will be done with the domain part of ObjectName.
    </li>
</ul>

<h3>Example Configurable Class Implementation</h3>
<pre>
TODO Static inner class.
TODO Static dynamic class.
</pre>

<h3>Model</h3>
<img alt="Configuration model" src="configuration.gif" />

<h3>TODOs</h3>
<ul>
    <li>Notifications: Can Notifications be done by the Registry
    implementation (E.g. JMX or JNDI Notification implementations)?
    Also, notifications are nought but java Events. In Heritrix currently, 
    there are two different (awkward) custom eventing mechanisms.
    We could move the these two systems to use a single system
    based on java Event or just use otifications.
    </li>
    <li>Fix Registry so doesn't have Store in its interface (Makes it
    harder doing simple Registry).
    </li>
    <li>Invocations: JMX advertises operations. JNDI has similar.
    Implication is that Configuration has reference to Configurable Class.
    </li>
    <li>Configuration Design: How does it know list of implementations. Once
    it has a Configurable Class, it can query for allowed values but bootstrapping and
    then adding in new implementations and having them noticed?
    Can't this just be a list in Configuration?  And then add to the list via
    the UI?  Add new implementations?
    </li>
    <li>Should Configurable#initialize go into a subclass of this interface?
    Otherwise any COnfigurable has to implement Registry interface.
    </li>
    <li>Serializing: Write out all values or just whats other than default?
    Option?</li>
    <li>Checkpointing: Do I just have to write out Configurations?
	If the Configuration carries current state of an object?  If
	the Configuration is updated with the state of all counters,
	should be sufficent?  Test.
	</li>
	<li>Pointers to Pointers of configuration so can have one instance
	of a configuration used by many?
	</li>
	<li>Groups of Configurables?</li>
	<li>Not reproducing complete Configurable in override, just
	the values that are overrideable and the differences?</li>
	<li>Set the not-writeable in Overriddes if Attribute is not
	overrideable?  How?</li>
    <li>Paul Jack suggests using annotations to mark Configurable classes
    and for marking whats configurable rather than an Interface and
    leveraging OpenMBean self-description with description, defaults and
    ranges. Investigate.  Would be sweet if could externalize all OpenMBean
    info.
    </li>
    <li>Geronimo GBeans are very like but not MBeans (See <a
    href="http://www-128.ibm.com/developerworks/library/os-ag-soapojo/index.html">Build
    an SOA framework with Apache Geronimo and POJOs"</a> and particularly the table
    1 here, <a 
    href="http://www-128.ibm.com/developerworks/library/os-ag-jmx/index.html">Manage
    Apache Geronimo with JMX</a>).
    Attributes and operations descriptions are built up in a static block
    at head of classes implementing GBeanLifeCycle to produce a static GBeanInfo
    object (similar to how we build MBeanInfo in prototype code here) only even uglier.
    See <a href="http://www.theserverside.com/news/thread.tss?thread_id=34309">Geronimo
    GBean Architecture</a>. You manage Geronimo via JMX so for some reason
    they judged it wise to adapt GBeans to produce MBean interfaces rather than just
    make all MBeans (as in JBOSS).  I'm unable to find justification why apache Geronimo
    crew would make something like MBeans but different and proprietary to Geronimo but
    it must exist somewhere.  Here is all I've found to date from above cited 
    Manage Apache ... with JMX: "Geronimo was created with JMX as the underlying kernel
    infrastructure...This structure has changed slightly over time, because using JMX as
    the framework for locating objects, interobject communication, method interception,
    and so on was seen as a stretch for JMX."
    </li>
</ul>

<h3>Comparison to old Settings system</h3>
<ul>
	<li>No boostrapping of core components is done by this system.
	Should make it so don't have to instantiate all that comes
	before in the configuration hierarchy -- e.g. A SettingsHandler and then
    a CrawlOrder and then a FetchHTTP -- testing or reusing in another context.
	</li>
    <li>Because we are implementing interfaces only to make a Configurable
    object, the core implementation can be done off in a base POJO and
    Configuration added later in a subclass.  This base POJO could then be used
    freely in other contexts without dependencies on Configurable (Settings).
    We couldn't do this with old setting system.  In the old system you couldn't
    use FetchHTTP without bringing over the settings system super
    classes (Brad suggests we take on the practise when refactoring of
    implementing base class first then subclassing to implement Configurable.
    He wants FetchHTTP and ARCWriter, etc).
    </li>
</ul>


<h2>Risks</h2>
<ul>
<li>Lookup into JMXRegistry will be too slow (Worst-case would be
Registry is a Singleton that all threads go via).  Should this be the case,
if caching is insufficent, things to try:
    <ul><li>Alternate JMX implementation.  In the past, the JVM Reference
    Implementation has been slammed as being dog slow. Other JMX
    implementations to try include MX4J (tomcat, geronimo, etc.) or
    JBOSS or our own JBOSS-like Map based version that shortcircuits
    JMX Agent if all in same JVM.
    </li>
    <li>Do Configuration once at head of processing chain.</li>
    </ul>
</li>
</ul>
</p>

<h2>Context</h2>
<p>This package is a refactoring of the org.archive.crawler.settings
package.  See <a href="">Settings Framework Refactoring</a> document
for a lead in on how this package came about.</p>

</body>
</html>
